<!doctype html>
<html lang=en>
<meta charset=UTF-8>
<meta content="width=device-width,initial-scale=1" name=viewport>
<title>Google</title>
<link href="https://github.com/crobperson/Overpriced-Haircut/blob/main/favicon.png?raw=true" rel=icon type=image/png>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>

::-webkit-scrollbar {
    width: 12px;
    background-color: #c0c0c0;
}

::-webkit-scrollbar-track {
    background: #c0c0c0;
    border-left: 1px solid #808080;
}

::-webkit-scrollbar-thumb {
    background: #a0a0a0;
    border: 1px solid #808080;
}

::-webkit-scrollbar-thumb:hover {
    background: #808080;
}


body {
    font-family: 'VT323', monospace;
    margin: 0;
    padding: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background-color: #008080;
    color: #000000;
}

.container {
    display: flex;
    flex-direction: column;
    width: 90%;
    max-width: 700px;
    height: 90vh;
    background-color: #c0c0c0;
    border: 2px solid #000000;
    box-shadow: inset -3px -3px #808080, inset 3px 3px #ffffff;
    overflow: hidden;
}

.header {
    padding: 10px;
    background-color: #c0c0c0;
    border-bottom: 2px solid #000000;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
}

.model-select-container,
.temperature-container {
    display: flex;
    align-items: center;
    margin: 5px 0;
    font-size: 16px;
}

.model-select-container label,
.temperature-container label {
    margin-right: 10px;
}

#model-select {
    padding: 5px;
    border: 2px solid #000000;
    box-shadow: inset -2px -2px #808080, inset 2px 2px #ffffff;
    font-family: 'VT323', monospace;
    font-size: 16px;
    background-color: #c0c0c0;
    color: #000000;
}


#chat-container {
    flex: 1;
    padding: 10px;
    overflow-y: auto;
    background-color: #ffffff;
    border: 2px solid #000000;
    margin: 10px;
    box-shadow: inset 2px 2px #808080, inset -2px -2px #ffffff;
    display: flex;
    flex-direction: column;
}

.message {
    padding: 10px;
    margin-bottom: 10px;
    border: 2px solid #000000;
    max-width: 75%;
    word-wrap: break-word;
    position: relative;
    white-space: pre-line;
    line-height: 1.4;
    font-size: 18px;
}

.user-message {
    background-color: #90ee90; /* Light green */
    align-self: flex-end;
    text-align: right;
    box-shadow: 2px 2px #000000;
}

.bot-message {
    background-color: #add8e6; 
    align-self: flex-start;
    box-shadow: 2px 2px #000000;
}

.bot-message pre {
    background-color: #000000;
    color: #00ff00; 
    padding: 10px;
    border: 2px solid #808080;
    overflow-x: auto;
}

.bot-message code {
    color: #00ff00;
}


.copy-button {
    position: absolute;
    top: 5px;
    right: 5px;
    background-color: #c0c0c0;
    border: 1px solid #000000;
    cursor: pointer;
    z-index: 10;
    box-shadow: 1px 1px #000000;
}

.copy-button:active {
    box-shadow: inset 1px 1px #000000;
}

.copy-button svg {
    width: 16px;
    height: 16px;
    fill: #000000;
}

#input-area {
    display: flex;
    padding: 10px;
    border-top: 2px solid #000000;
    background-color: #c0c0c0;
    align-items: center;
}

#input-box {
    flex-grow: 1;
    padding: 8px;
    border: 2px solid #000000;
    box-shadow: inset 2px 2px #808080, inset -2px -2px #ffffff;
    resize: none;
    font-size: 16px;
    outline: 0;
    background-color: #ffffff;
    color: #000000;
    line-height: 1.5;
    font-family: 'VT323', monospace;
}

#input-box::placeholder {
    color: #808080;
}


#send-button {
    padding: 8px 20px;
    margin-left: 10px;
    background-color: #c0c0c0;
    color: #000000;
    border: 2px solid #000000;
    cursor: pointer;
    font-size: 16px;
    font-family: 'VT323', monospace;
    box-shadow: 2px 2px #000000;
}

#send-button:active {
    box-shadow: inset 2px 2px #000000;
}

.file-upload-label {
    display: inline-block;
    padding: 8px 15px;
    margin-right: 10px;
    background-color: #c0c0c0;
    color: #000000;
    border: 2px solid #000000;
    cursor: pointer;
    font-size: 16px;
    font-family: 'VT323', monospace;
    box-shadow: 2px 2px #000000;
}

.file-upload-label:active {
    box-shadow: inset 2px 2px #000000;
}

#file-input {
    display: none;
}

#typing-indicator {
    padding: 10px;
    font-style: italic;
    color: #000000;
    background-color: #c0c0c0;
    border-top: 2px solid #000000;
    display: none;
    font-size: 16px;
}

@media (max-width:768px) {
    .container {
        width: 95%;
        height: 95vh;
    }

    .message {
        max-width: 85%;
    }
}

@media (max-width:480px) {
    .header {
        flex-direction: column;
        align-items: flex-start;
    }

    .model-select-container,
    .temperature-container {
        width: 100%;
        justify-content: space-between;
        margin-bottom: 10px;
    }

    #send-button {
        padding: 8px 12px;
    }

    .file-upload-label {
        padding: 8px 12px;
    }
}

.modal {
    display: none;
    position: fixed;
    z-index: 100;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, .5);
}

.modal-content {
    background-color: #c0c0c0;
    color: #000000;
    margin: 15% auto;
    padding: 20px;
    border: 2px solid #000000;
    width: 80%;
    max-width: 600px;
    box-shadow: inset -3px -3px #808080, inset 3px 3px #ffffff;
}

.close {
    color: #000000;
    float: right;
    font-size: 28px;
    font-weight: 700;
    cursor: pointer;
}

.close:hover,
.close:focus {
    color: #ff0000;
}

.button-primary,
.button-secondary {
    padding: 8px 16px;
    margin: 10px 5px;
    background-color: #c0c0c0;
    color: #000000;
    border: 2px solid #000000;
    cursor: pointer;
    font-size: 14px;
    font-family: 'VT323', monospace;
    box-shadow: 2px 2px #000000;
}

.button-primary:active,
.button-secondary:active {
    box-shadow: inset 2px 2px #000000;
}

#last-updated {
    position: fixed;
    top: 10px;
    right: 10px;
    font-size: 14px;
    color: #000000;
    background-color: #c0c0c0;
    padding: 5px 10px;
    border: 1px solid #000000;
    font-weight: 700;
    z-index: 100;
}

.footer-text {
    font-size: 14px;
    text-align: center;
    color: #000000;
    padding: 10px;
}

.popup-message {
    position: fixed;
    top: -60px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #ffff00;
    color: #000000;
    padding: 10px 20px;
    border: 2px solid #000000;
    z-index: 1000;
    opacity: 0;
    transition: opacity .5s ease-out, top .5s ease-out;
    box-shadow: 3px 3px #000000;
}

.popup-message.show {
    opacity: 1;
    top: 20px;
}

#temperature-value {
    font-size: 16px;
    color: #000000;
    width: 30px;
    text-align: right;
}

#file-names {
    font-size: 14px;
    color: #000000;
    margin-left: 10px;
    margin-top: 5px;
    display: inline-block;
    max-width: 50%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    vertical-align: middle;
}

#overlay-image {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: url('https://github.com/crobperson/Overpriced-Haircut/blob/main/Screenshot.png?raw=true');
    background-size: cover;
    background-repeat: no-repeat;
    background-position: center;
    background-color: rgba(0,0,0,0.5);
    z-index: 1001;
    pointer-events: none;
}

#overlay-image.show {
    display: block;
}
#file-preview-container {
    display: flex;
    gap: 5px;
    margin-left: 10px;
    margin-right: 5px;
    max-height: 45px;
    overflow: hidden;
    align-items: center;
}

.file-preview-image {
    max-height: 40px;
    max-width: 40px;
    height: 40px;
    width: 40px;
    object-fit: cover;
    border: 2px solid #000000;
}

.message-image {
    max-width: 150px;
    max-height: 150px;
    margin-top: 8px;
    cursor: pointer;
    display: block;
    border: 2px solid #000000;
}

.generated-message-image {
    max-width: 100%;
    max-height: 500px;
    margin-top: 8px;
    display: block;
    border: 2px solid #000000;
    object-fit: contain;
}


.user-message .images-container {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    margin-top: 5px;
    justify-content: flex-end;
}

.user-message > p {
    margin-bottom: 5px;
}

</style>
<script src=https://cdn.jsdelivr.net/npm/marked/marked.min.js></script>
<div class=container>
<div class=header>
<div class=model-select-container><label for=model-select>AI Model:</label> <select id=model-select>
<option value=gemini-2.5-flash>Clifton Flash</option>
<option value=gemini-2.5-pro>Clifton Pro</option>
<option value=gemini-2.0-flash-preview-image-generation>Clifton Image Gen</option>
</select></div>
<div class=temperature-container><label for=temperature-slider>Temp:</label> <input id=temperature-slider
type=range max=1 min=0 step=0.1 value=1> <span id=temperature-value>1.0</span></div>
<div>
<button id=changelog-button class=button-primary>Changelog</button>
<button id=clear-chat-button class=button-secondary>Clear Chat</button>
<button id=regenerate-button class=button-secondary>Regenerate</button>
</div>
</div>
<div id=chat-container></div>
<div id=typing-indicator>Clifton is typing...</div>
<div id=input-area><label for=file-input class=file-upload-label>Choose File</label> <input id=file-input type=file
accept=.html,image/*,application/pdf,audio/* multiple> <span id=file-names></span> <div id="file-preview-container"></div><textarea id=input-box
placeholder="Enter your message..." rows=1></textarea> <button id=send-button>Send</button></div>
<p class=footer-text>Clifton® is not affiliated with Google in anyway!</div>
<div id=popup-container></div>
<div class=modal id=changelogModal>
<div class=modal-content><span class=close>×</span>
<h2>Changelog</h2>
<p><strong>Version 2.1 (May 10, 2025)</strong><br>- Added Image Generation model (Clifton Image Gen). Supports text-to-image and image-to-image (editing by uploading an image with your prompt).<br>
<p><strong>Version 2.0 (May 9, 2025)</strong><br>- Revamped the S**tty UI.<br><p><strong>Version 1.83 (April 9, 2025)</strong><br>- Added Image Previews Along With General Improvements<br><p><strong>Version 1.82 (March 31, 2025)</strong><br>- Improved the Clifton pro and flash model (I like chicken)<br><p><strong>Version 1.81 (Feb 6, 2025)</strong><br>- Improved the Clifton pro model (I've ran out of ideas)<br><p><strong>Version 1.8 (January 31, 2025)</strong><br>- Press ctrl 3 times<br><p><strong>Version 1.7 (January 22, 2025)</strong><br>- The Thinker is back... (Currently the best model)<br><p><strong>Version 1.65 (January 16, 2025)</strong><br>- Message Regeneration<br><p><strong>Version 1.6 (January 14, 2025)</strong><br>- Fixed bug!!!<br>
</div>
</div>
<div id="overlay-image"></div>
<script>
const b = ["01000001 01001001 01111010 01100001 01010011 01111001 01000010 01110000 01101000 01110011 01110010 01001001 00101101 01110001 01110110 01101001 01001101 01111000 01101111 01100001 01101111 01110110 01101100 00110000 01011001 01110111 01111000 01011111 01101001 01001101 01111000 01010011 01001011 00110100 01001110 00110000 01101000 01100110 01001101", "01000001 01001001 01111010 01100001 01010011 01111001 01000001 01001110 01000100 01011010 01110001 01001110 01111010 01101000 01001010 01010100 00110010 01110101 00110110 01011000 01001111 01101010 01000001 01111010 01001001 01010010 00110001 01100001 00101101 00110101 00101101 01101110 01001110 01110101 01000111 01100011 01100010 01110110 00110100"];
function str(e) {
e = e.replace(/[^01]/g, "");
let t = "";
for (let n = 0; n < e.length; n += 8) {
let o = e.substring(n, n + 8);
o.length < 8 ? console.warn(`Incomplete byte found at index ${n}: ${o}. Skipping.`) : t += String.fromCharCode(parseInt(o, 2))
}
return t
}
const k = b.map(str),
u = "https://generativelanguage.googleapis.com",
c = document.getElementById("chat-container"),
i = document.getElementById("input-box"),
m = document.getElementById("send-button"),
t = document.getElementById("typing-indicator"),
s = document.getElementById("model-select"),
f = document.getElementById("file-input"),
p = document.getElementById("popup-container"),
fileNamesSpan = document.getElementById("file-names"),
filePreviewContainer = document.getElementById("file-preview-container");

let h = [],
n = "gemini-2.5-flash",
v = !1, 
temp = 1; 


let currentImagePreviews = [];
let lastApiCallHistory = [];

const tempSlider = document.getElementById("temperature-slider"),
tempValueDisplay = document.getElementById("temperature-value");

function d(e) {
if (v) {
const t = document.createElement("div");
t.classList.add("message", "bot-message"), t.textContent = `Error: ${e}`, c.appendChild(t), c.scrollTop = c.scrollHeight
}
}


function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
        reader.readAsDataURL(file);
    });
}


async function g(apiKey, contents, modelName, outputElement) {
const safetySettings = [
{ "category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE" },
{ "category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE" },
{ "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE" },
{ "category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE" },
];

const apiRequestBody = {
contents: contents,
generationConfig: {
temperature: temp,
maxOutputTokens: 65536,
},
safetySettings: safetySettings,
};


const response = await fetch(`${u}/v1beta/models/${modelName}:streamGenerateContent?alt=sse&key=${apiKey}`, {
method: "POST",
headers: {"Content-Type": "application/json"},
body: JSON.stringify(apiRequestBody)
});

if (!response.ok) {
let errorMsg = "Unknown API error";
try {
const errorData = await response.json();
errorMsg = errorData.error?.message || JSON.stringify(errorData);
} catch (e) {
errorMsg = `API request failed with status ${response.status}: ${response.statusText}`;
}
throw new Error(errorMsg);
}

const reader = response.body.getReader();
let accumulatedResponse = "";
let decodedChunk = "";
outputElement.innerHTML = "";

while (true) {
const { done, value } = await reader.read();
if (done) break;
decodedChunk += new TextDecoder().decode(value);
let newlineIndex;
while ((newlineIndex = decodedChunk.indexOf('\n')) >= 0) {
const line = decodedChunk.substring(0, newlineIndex).trim();
decodedChunk = decodedChunk.substring(newlineIndex + 1);
if (line.startsWith("data:")) {
try {
const jsonData = JSON.parse(line.substring(5));
if (jsonData.candidates && jsonData.candidates[0]?.content?.parts) {
const textPart = jsonData.candidates[0].content.parts[0]?.text;
if (textPart) {
accumulatedResponse += textPart;
outputElement.innerHTML = marked.parse(accumulatedResponse);
c.scrollTop = c.scrollHeight;
}
}
if (jsonData.candidates && jsonData.candidates[0]?.finishReason && jsonData.candidates[0].finishReason !== "STOP") {
console.warn("Stream stopped for reason:", jsonData.candidates[0].finishReason);
}
if (jsonData.promptFeedback?.blockReason) {
console.error("Request blocked:", jsonData.promptFeedback.blockReason);
throw new Error(`Request blocked due to safety settings: ${jsonData.promptFeedback.blockReason}`);
}
} catch (e) {
console.error("Error parsing SSE data line:", e, "Line:", line);
}
}
}
}
outputElement.innerHTML = marked.parse(accumulatedResponse);
cC();
return accumulatedResponse;
}

async function generateImageApiCall(apiKey, contents, modelName) {
    const safetySettings = [
        { "category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE" },
        { "category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE" },
        { "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE" },
        { "category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE" },
    ];

    const apiRequestBody = {
        contents: contents,
        generationConfig: {
            responseModalities: ["TEXT", "IMAGE"]
        },
        safetySettings: safetySettings,
    };

    const response = await fetch(`${u}/v1beta/models/${modelName}:generateContent?key=${apiKey}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(apiRequestBody)
    });

    if (!response.ok) {
        let errorMsg = "Unknown API error (Image Generation)";
        try {
            const errorData = await response.json();
            errorMsg = errorData.error?.message || JSON.stringify(errorData);
        } catch (e) {
            errorMsg = `Image API request failed with status ${response.status}: ${response.statusText}`;
        }
        throw new Error(errorMsg);
    }

    const responseData = await response.json();
    let botTextResponse = "";
    let botImageBase64 = null;
    let botImageMimeType = "image/png";

    if (responseData.candidates && responseData.candidates[0]?.content?.parts) {
        for (const part of responseData.candidates[0].content.parts) {
            if (part.text) {
                botTextResponse += part.text;
            }
            if (part.inlineData && part.inlineData.data) {
                botImageBase64 = part.inlineData.data;
                botImageMimeType = part.inlineData.mimeType;
            }
        }
    }

    if (responseData.promptFeedback?.blockReason) {
        console.error("Request blocked (Image Gen):", responseData.promptFeedback.blockReason);
        throw new Error(`Request blocked due to safety settings (Image Gen): ${responseData.promptFeedback.blockReason}`);
    }
    return { text: botTextResponse.trim(), imageBase64: botImageBase64, imageMimeType: botImageMimeType };
}



async function a() {
    const textInput = i.value.trim();
    const actualFiles = Array.from(f.files);
    const previewsToShow = [...currentImagePreviews];

    if (textInput === "" && actualFiles.length === 0) return;

    const userMessageDiv = document.createElement("div");
    userMessageDiv.classList.add("message", "user-message");
    if (textInput) {
        const textElement = document.createElement('p');
        textElement.textContent = textInput;
        userMessageDiv.appendChild(textElement);
    }
    if (previewsToShow.length > 0) {
        const imageContainer = document.createElement('div');
        imageContainer.className = 'images-container';
        previewsToShow.forEach(previewData => {
            const img = document.createElement('img');
            img.src = previewData.dataUrl;
            img.classList.add('message-image');
            img.title = previewData.name;
            img.alt = previewData.name;
            imageContainer.appendChild(img);
        });
        userMessageDiv.appendChild(imageContainer);
    }
    if (!textInput && previewsToShow.length === 0 && actualFiles.length > 0) {
        const fileInfoElement = document.createElement('p');
        fileInfoElement.textContent = `Attached ${actualFiles.length} file(s): ${actualFiles.map(file => file.name).join(', ')}`;
        userMessageDiv.appendChild(fileInfoElement);
    }
    c.appendChild(userMessageDiv);
    c.scrollTop = c.scrollHeight;

    i.value = "";
    f.value = "";
    fileNamesSpan.textContent = '';
    filePreviewContainer.innerHTML = '';
    currentImagePreviews = [];

    t.style.display = "block";

    let newUserParts = [];
    if (textInput) {
        newUserParts.push({ text: textInput });
    }

    if (n === "gemini-2.0-flash-preview-image-generation") {
        let hasTextPrompt = newUserParts.some(p => p.text && p.text.trim() !== "");
        if (!hasTextPrompt) {
            console.log("Image Gen: Text prompt is required.");
            t.style.display = "none";
            const errDiv = document.createElement("div");
            errDiv.classList.add("message", "bot-message");
            errDiv.textContent = "For image generation, a text prompt is required. You can optionally include one image for editing.";
            c.appendChild(errDiv);
            c.scrollTop = c.scrollHeight;
            return; 
        }

        if (actualFiles.length > 0) {
            const imageFile = actualFiles.find(file => file.type.startsWith('image/'));
            if (imageFile) {
                try {
                    const base64Data = await fileToBase64(imageFile);
                    newUserParts.push({
                        inline_data: {
                            mime_type: imageFile.type,
                            data: base64Data
                        }
                    });
                } catch (error) {
                    console.error(`Error converting image ${imageFile.name} to base64:`, error);
                    d(`Failed to process image ${imageFile.name} for generation: ${error.message}`);
                }
            }
        }
        const userMessageForHistory = { role: "user", parts: newUserParts };
        h.push(userMessageForHistory);
        await w(newUserParts);
    } else {
        let fileProcessingPromises = actualFiles.map(async (file) => {
            try {
                if (file.type.startsWith('text/') || file.type === 'text/html' || file.type === 'application/json' || file.type === 'application/xml') {
                    const content = await fT(file);
                    return { text: `--- File Start: ${file.name} ---\n${content}\n--- File End: ${file.name} ---` };
                } else if (file.type.startsWith('image/') || file.type.startsWith('audio/') || file.type === 'application/pdf' || file.type.startsWith('video/')) {
                    const uploadedFile = await z(file);
                    return { file_data: { mime_type: file.type, file_uri: uploadedFile.file.uri } };
                } else {
                    console.warn(`Unsupported file type for direct API processing: ${file.name} (${file.type}). Sending as text note.`);
                    return { text: `[Attached file: ${file.name} (${file.type}) - Content not processed]` };
                }
            } catch (error) {
                console.error(`Error processing file ${file.name}:`, error);
                d(`Failed to process file ${file.name}: ${error.message}`);
                return null;
            }
        });
        const filePartsForApi = (await Promise.all(fileProcessingPromises)).filter(p => p !== null);
        newUserParts.push(...filePartsForApi);

        if (newUserParts.length > 0) {
            const newUserMessage = { role: "user", parts: newUserParts };
            const historyForApi = [...h, newUserMessage];
            h.push(newUserMessage);
            await w(historyForApi);
        } else {
            console.log("No valid content (text or processed files) to send.");
            t.style.display = "none";
        }
    }
}



function fT(file) { 
return new Promise(((resolve, reject) => {
const reader = new FileReader;
reader.onload = e => resolve(e.target.result);
reader.onerror = e => reject(e);
reader.readAsText(file);
}))
}


async function w(conversationHistoryOrPartsForImageGen) {

    if (n === "gemini-2.0-flash-preview-image-generation") {
        lastApiCallHistory = conversationHistoryOrPartsForImageGen; 
    } else {
        lastApiCallHistory = [...conversationHistoryOrPartsForImageGen]; 
    }

    let botReplied = false;
    const botMessageDiv = document.createElement("div");
    botMessageDiv.classList.add("message", "bot-message");
    botMessageDiv.innerHTML = "<i>Clifton is typing...</i>";
    c.appendChild(botMessageDiv);
    c.scrollTop = c.scrollHeight;
    t.style.display = 'block';

    for (const apiKey of k) {
        try {
            if (n === "gemini-2.0-flash-preview-image-generation") {
                const userParts = conversationHistoryOrPartsForImageGen;
                const imageGenContents = [{ role: "user", parts: userParts }];

                const result = await generateImageApiCall(apiKey, imageGenContents, n);
                botMessageDiv.innerHTML = ''; 

                let contentAdded = false;
                let modelPartsForHistory = [];

                if (result.text) {
                    const textElement = document.createElement('div');
                    textElement.innerHTML = marked.parse(result.text);
                    botMessageDiv.appendChild(textElement);
                    modelPartsForHistory.push({ text: result.text });
                    contentAdded = true;
                }
                if (result.imageBase64) {
                    const imgElement = document.createElement('img');
                    imgElement.src = `data:${result.imageMimeType};base64,${result.imageBase64}`;
                    imgElement.classList.add('generated-message-image');
                    imgElement.alt = "Generated Image";
                    botMessageDiv.appendChild(imgElement);
                    contentAdded = true;
                    if (!result.text) {
                        modelPartsForHistory.push({ text: "[Image Generated]" });
                    }
                }

                if (!contentAdded) {
                    botMessageDiv.innerHTML = "<i>Image model returned no text or image.</i>";
                }

                if (modelPartsForHistory.length > 0) {
                    h.push({ role: "model", parts: modelPartsForHistory });
                }
                botReplied = true;
                break;
            } else {
                const botResponseText = await g(apiKey, conversationHistoryOrPartsForImageGen, n, botMessageDiv);
                if (botResponseText !== null && botResponseText.trim() !== "") {
                    h.push({ role: "model", parts: [{ text: botResponseText }] });
                    botReplied = true;
                    break;
                } else if (botResponseText === "") {
                    botMessageDiv.innerHTML = "<i>Received an empty response.</i>";
                   
                    botReplied = true;
                    break;
                }
            }
        } catch (error) {
            console.error(`Error during API call with key [...] for model ${n}: ${error.message}`);
            d(error.message);
            botMessageDiv.innerHTML = `<span style="color: red;">Error: ${error.message}</span>`;
        }
    }

    if (!botReplied && !botMessageDiv.innerHTML.includes("Error:")) {
        botMessageDiv.textContent = "I'm sorry, I'm currently unable to process your request after trying all available resources. Please try again later.";
    }

    t.style.display = "none";
    c.scrollTop = c.scrollHeight;
    cC();
}



async function z(file) {
return new Promise(async (resolve, reject) => {
try {
const uploadApiKey = k[0];
if (!uploadApiKey) return reject(new Error("No API key available for file uploads."));

const startResponse = await fetch(`${u}/upload/v1beta/files?key=${uploadApiKey}`, {
method: "POST",
headers: {
"X-Goog-Upload-Protocol": "resumable",
"X-Goog-Upload-Command": "start",
"X-Goog-Upload-Header-Content-Length": file.size.toString(),
"X-Goog-Upload-Header-Content-Type": file.type,
"Content-Type": "application/json"
},
body: JSON.stringify({ file: { display_name: file.name }})
});

if (!startResponse.ok || startResponse.status !== 200) {
let errorMsg = `Failed to start upload (Status: ${startResponse.status})`;
try { errorMsg = (await startResponse.json()).error?.message || errorMsg; } catch (_) {}
return reject(new Error(errorMsg));
}

const uploadUrl = startResponse.headers.get("X-Goog-Upload-URL");
if (!uploadUrl) return reject(new Error("Failed to get upload URL from start response."));

const uploadResponse = await fetch(uploadUrl, {
method: "POST",
headers: {
"X-Goog-Upload-Offset": "0",
"X-Goog-Upload-Command": "upload, finalize"
},
body: file
});

if (!uploadResponse.ok) {
let errorMsg = `File upload failed (Status: ${uploadResponse.status})`;
try {
const errorData = await uploadResponse.json();
errorMsg = errorData.error?.message || JSON.stringify(errorData) || errorMsg;
} catch (_) { errorMsg += `: ${uploadResponse.statusText}`; }
return reject(new Error(errorMsg));
}
const uploadResult = await uploadResponse.json();
if (!uploadResult.file?.uri) return reject(new Error("Upload succeeded but response did not contain file URI."));
resolve({ file: { uri: uploadResult.file.uri } });
} catch (error) {
console.error("File Upload z() Error:", error);
reject(error);
}
});
}


tempSlider.addEventListener("input", () => {
temp = parseFloat(tempSlider.value);
tempValueDisplay.textContent = temp.toFixed(1);
const isImageModel = n === "gemini-2.0-flash-preview-image-generation";
document.querySelector('.temperature-container').style.display = isImageModel ? 'none' : 'flex';

});

s.addEventListener("change", () => {
n = s.value;
console.log(`Model switched to: ${n}`);
const isImageModel = n === "gemini-2.0-flash-preview-image-generation";
document.querySelector('.temperature-container').style.display = isImageModel ? 'none' : 'flex';



});

m.addEventListener("click", a);
i.addEventListener("keydown", (e => { if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); a(); }}));

f.addEventListener('change', function() {
fileNamesSpan.textContent = '';
filePreviewContainer.innerHTML = '';
currentImagePreviews = [];
let nonImageFileNames = [];
if (f.files && f.files.length > 0) {
const filePromises = Array.from(f.files).map(file => {
return new Promise((resolve) => {
if (file.type.startsWith('image/')) {
const reader = new FileReader();
reader.onload = (e) => {
const dataUrl = e.target.result;
currentImagePreviews.push({ name: file.name, dataUrl: dataUrl });
const img = document.createElement('img');
img.src = dataUrl;
img.classList.add('file-preview-image');
img.title = file.name;
img.alt = file.name;
filePreviewContainer.appendChild(img);
resolve();
};
reader.onerror = () => { console.error("Error reading file:", file.name); nonImageFileNames.push(file.name + " (preview failed)"); resolve(); };
reader.readAsDataURL(file);
} else { nonImageFileNames.push(file.name); resolve(); }
});
});
Promise.all(filePromises).then(() => {
if (nonImageFileNames.length > 0) { fileNamesSpan.textContent = nonImageFileNames.join(', '); }
filePreviewContainer.style.display = currentImagePreviews.length > 0 ? 'flex' : 'none';
});
} else { filePreviewContainer.style.display = 'none'; }
});


const ld = document.createElement("p");
ld.id = "last-updated";
ld.textContent = "Last updated: May 22th, 2025, 10:00 AM"; 
document.body.appendChild(ld);

const ch = document.getElementById("changelogModal"),
bb = document.getElementById("changelog-button"),
cl = document.getElementsByClassName("close")[0];
if (bb && ch && cl) {
bb.onclick = function() { ch.style.display = "block" };
cl.onclick = function() { ch.style.display = "none" };
window.onclick = function(event) { if (event.target == ch) { ch.style.display = "none"; }};
} else { console.warn("Changelog modal elements not found."); }

function sp(message) {
const popup = document.createElement("div");
popup.classList.add("popup-message");
popup.textContent = message;
p.appendChild(popup);
popup.offsetWidth;
popup.classList.add("show");
setTimeout(() => {
popup.classList.remove("show");
setTimeout(() => { if (popup.parentNode) { popup.remove(); }}, 500);
}, 2500);
}

function cC() {
c.querySelectorAll(".bot-message pre > code").forEach((codeBlock => {
const preElement = codeBlock.parentElement;
if (preElement && !preElement.querySelector(".copy-button")) {
const button = document.createElement("button");
button.className = "copy-button";
button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>';
button.title = "Copy code";
button.addEventListener("click", () => {
navigator.clipboard.writeText(codeBlock.innerText).then(() => {
button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M9 16.17 4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>';
button.title = "Copied!";
setTimeout(() => {
button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>';
button.title = "Copy code";
}, 1500);
}).catch(err => { console.error("Failed to copy code: ", err); button.title = "Copy failed!"; });
});
if (getComputedStyle(preElement).position === 'static') { preElement.style.position = "relative"; }
preElement.appendChild(button);
}
}));
}

const cb = document.getElementById("clear-chat-button");
if (cb) {
cb.addEventListener("click", () => {
c.innerHTML = ""; h = []; lastApiCallHistory = []; sp("Chat cleared.");
});
}

const regenerateButton = document.getElementById("regenerate-button");
if (regenerateButton) {
    regenerateButton.addEventListener("click", async () => {
        if (h.length === 0 || h[h.length - 1].role === 'user') {
            sp("Nothing to regenerate from the bot.");
            return;
        }


        h.pop();
        const botMessages = c.querySelectorAll(".message.bot-message");
        if (botMessages.length > 0) {
            c.removeChild(botMessages[botMessages.length - 1]); 
        }

        if (lastApiCallHistory && ( (Array.isArray(lastApiCallHistory) && lastApiCallHistory.length > 0) || (typeof lastApiCallHistory === 'object' && Object.keys(lastApiCallHistory).length > 0) ) ) {
            sp("Regenerating response...");

            await w(lastApiCallHistory);
        } else {
            sp("Cannot regenerate: No previous API call context found.");
        }
    });
} else { console.warn("Regenerate button not found."); }


document.addEventListener("keydown", (function(event) {
if (event.altKey && event.shiftKey && event.key === 'E') {
v = !v; sp(v ? "Error messages will be shown in chat." : "Error messages hidden.");
}
}));

let ctrlCount = 0;
let ctrlPressedTimeout;
const overlayImage = document.getElementById('overlay-image');
if (overlayImage) {
document.addEventListener('keydown', function(event) {
if (event.key === 'Control' || event.key === 'Meta') {
ctrlCount++;
clearTimeout(ctrlPressedTimeout);
if (ctrlCount >= 3) { ctrlCount = 0; overlayImage.classList.toggle('show'); }
else { ctrlPressedTimeout = setTimeout(() => { ctrlCount = 0; }, 500); }
} else if (!event.ctrlKey && !event.metaKey) {
if (event.key !== 'Control' && event.key !== 'Meta') { ctrlCount = 0; clearTimeout(ctrlPressedTimeout); }
}
});
const preloadImage = new Image();
preloadImage.src = 'https://github.com/crobperson/Overpriced-Haircut/blob/main/Screenshot.png?raw=true';
} else { console.warn("Overlay image element not found."); }


const initialIsImageModel = s.value === "gemini-2.0-flash-preview-image-generation";
document.querySelector('.temperature-container').style.display = initialIsImageModel ? 'none' : 'flex';


cC();
</script>
</html>
