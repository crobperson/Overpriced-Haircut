<!doctype html>
<html lang=en>
<meta charset=UTF-8>
<meta content="width=device-width,initial-scale=1" name=viewport>
<title>Google</title>
<link href="https://github.com/crobperson/Overpriced-Haircut/blob/main/favicon.png?raw=true" rel=icon type=image/png>
<style>
/* Basic Scrollbar Styling for Webkit browsers (Optional but good for dark mode) */
::-webkit-scrollbar {
    width: 10px;
}

::-webkit-scrollbar-track {
    background: #282828; /* Dark track */
}

::-webkit-scrollbar-thumb {
    background: #555; /* Darker thumb */
    border-radius: 5px;
}

::-webkit-scrollbar-thumb:hover {
    background: #777; /* Lighter thumb on hover */
}


body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    /* Dark Mode Background */
    background-color: #121212;
    /* Dark Mode Text Color */
    color: #e0e0e0;
}

.container {
    display: flex;
    flex-direction: column;
    width: 90%;
    max-width: 700px;
    height: 90vh;
    /* Dark Mode Container Background */
    background-color: #282828;
    border-radius: 10px;
    /* Shadows are less effective in dark mode, often removed or subtle */
    /* box-shadow: 0 4px 12px rgba(0, 0, 0, .15); */
    overflow: hidden;
}

.header {
    padding: 15px 25px;
    /* Dark Mode Header Background */
    background-color: #333;
    /* Dark Mode Border */
    border-bottom: 1px solid #444;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
}

.model-select-container,
.temperature-container {
    display: flex;
    align-items: center;
    margin: 5px 0;
}

.model-select-container label,
.temperature-container label {
    margin-right: 10px;
    font-size: 14px;
    /* Dark Mode Label Color */
    color: #bbbbbb;
}

#model-select {
    padding: 8px;
    /* Dark Mode Border */
    border: 1px solid #555;
    border-radius: 4px;
    font-size: 14px;
    /* Dark Mode Text Color */
    color: #e0e0e0;
    /* Dark Mode Background */
    background-color: #444;
}


#chat-container {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    /* Dark Mode Chat Background */
    background-color: #1e1e1e;
    display: flex;
    flex-direction: column;
}

.message {
    padding: 12px 18px;
    margin-bottom: 15px;
    border-radius: 20px;
    max-width: 75%;
    word-wrap: break-word;
    position: relative;
    white-space: pre-line;
    line-height: 1.4;
    font-size: 15px;
    /* Remove shadows from messages in dark mode */
    /* box-shadow: 0 2px 4px rgba(0, 0, 0, .1); */
}

.user-message {
    /* Dark Mode User Message Background (Dark Teal) */
    background-color: #004d40;
    /* Dark Mode User Message Text Color */
    color: #e0e0e0;
    align-self: flex-end;
    text-align: right;
}

.bot-message {
    /* Dark Mode Bot Message Background (Dark Grey) */
    background-color: #333;
    /* Dark Mode Bot Message Text Color */
    color: #e0e0e0;
    align-self: flex-start;
    /* Remove shadows from messages in dark mode */
    /* box-shadow: 0 2px 4px rgba(0, 0, 0, .1); */
}

/* Style for code blocks within bot messages */
.bot-message pre {
    background-color: #444; /* Darker background for code */
    padding: 10px;
    border-radius: 5px;
    overflow-x: auto; /* Ensure code blocks are scrollable */
}

.bot-message code {
    color: #e0e0e0; /* Light text for code */
}


.copy-button {
    position: absolute;
    top: 8px;
    right: 8px;
    background-color: transparent;
    border: none;
    cursor: pointer;
    z-index: 10;
    opacity: .7;
    transition: opacity .3s;
}

.copy-button:hover {
    opacity: 1;
}

.copy-button svg {
    width: 18px;
    height: 18px;
    /* Dark Mode Copy Button Icon Color */
    fill: #bbb;
}

#input-area {
    display: flex;
    padding: 15px 20px;
    /* Dark Mode Border */
    border-top: 1px solid #444;
    /* Dark Mode Input Area Background */
    background-color: #333;
    align-items: center;
}

#input-box {
    flex-grow: 1;
    padding: 12px 15px;
    /* Dark Mode Border */
    border: 1px solid #555;
    border-radius: 25px;
    resize: none;
    font-size: 15px;
    outline: 0;
    /* Dark Mode Input Background */
    background-color: #444;
    /* Dark Mode Text Color */
    color: #e0e0e0;
    line-height: 1.5;
}

#input-box::placeholder {
    /* Dark Mode Placeholder Color */
    color: #bbb;
}


#send-button {
    padding: 10px 25px;
    margin-left: 15px;
    /* Dark Mode Send Button Background (Teal) */
    background-color: #009688;
    color: #fff;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    font-size: 15px;
    transition: background-color .3s ease;
    /* Remove shadows */
    /* box-shadow: 0 2px 4px rgba(0, 0, 0, .1); */
}

#send-button:hover {
    /* Dark Mode Send Button Hover Background */
    background-color: #00796b;
}

.file-upload-label {
    display: inline-block;
    padding: 10px 20px;
    margin-right: 10px;
    /* Dark Mode File Upload Background */
    background-color: #555;
    color: #fff;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    font-size: 15px;
    transition: background-color .3s ease;
    /* Remove shadows */
    /* box-shadow: 0 2px 4px rgba(0, 0, 0, .1); */
}

.file-upload-label:hover {
    /* Dark Mode File Upload Hover Background */
    background-color: #666;
}

#file-input {
    display: none;
}

#typing-indicator {
    padding: 10px 20px;
    font-style: italic;
    /* Dark Mode Typing Indicator Color */
    color: #bbb;
    /* Dark Mode Typing Indicator Background */
    background-color: #333;
    /* Dark Mode Border */
    border-top: 1px solid #444;
    display: none;
    font-size: 14px;
}

@media (max-width:768px) {
    .container {
        width: 95%;
        height: 95vh;
    }

    .message {
        max-width: 85%;
    }
}

@media (max-width:480px) {
    .header {
        flex-direction: column;
        align-items: flex-start;
    }

    .model-select-container,
    .temperature-container {
        width: 100%;
        justify-content: space-between;
        margin-bottom: 10px;
    }

    #send-button {
        padding: 10px 15px;
    }

    .file-upload-label {
        padding: 10px 15px;
    }
}

.modal {
    display: none;
    position: fixed;
    z-index: 100;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    /* Dark Mode Modal Overlay Background */
    background-color: rgba(0, 0, 0, .7);
}

.modal-content {
    /* Dark Mode Modal Content Background */
    background-color: #282828;
    /* Dark Mode Text Color */
    color: #e0e0e0;
    margin: 10% auto;
    padding: 20px;
    /* Dark Mode Border */
    border: 1px solid #444;
    width: 80%;
    max-width: 600px;
    border-radius: 8px;
    /* Remove shadows */
    /* box-shadow: 0 4px 8px rgba(0, 0, 0, .1); */
}

.close {
    /* Dark Mode Close Button Color */
    color: #bbb;
    float: right;
    font-size: 28px;
    font-weight: 700;
    cursor: pointer;
}

.close:focus,
.close:hover {
    /* Dark Mode Close Button Hover Color */
    color: #fff;
}

.button-primary {
    padding: 8px 16px;
    margin: 10px 5px;
    /* Dark Mode Primary Button Background (Darker Green) */
    background-color: #218838;
    color: #fff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color .3s ease;
    /* Remove shadows */
    /* box-shadow: 0 2px 4px rgba(0, 0, 0, .1); */
}

.button-primary:hover {
    /* Dark Mode Primary Button Hover Background */
    background-color: #1e7e34;
}

.button-secondary {
    padding: 8px 16px;
    margin: 10px 5px;
    /* Dark Mode Secondary Button Background (Darker Red) */
    background-color: #c82333;
    color: #fff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color .3s ease;
    /* Remove shadows */
    /* box-shadow: 0 2px 4px rgba(0, 0, 0, .1); */
}

.button-secondary:hover {
    /* Dark Mode Secondary Button Hover Background */
    background-color: #bd2130;
}

#last-updated {
    position: fixed;
    top: 10px;
    right: 10px;
    font-size: 12px;
    /* Dark Mode Timestamp Color */
    color: #bbb;
    /* Dark Mode Timestamp Background (Dark Translucent) */
    background-color: rgba(40, 40, 40, 0.8);
    padding: 5px 10px;
    border-radius: 5px;
    /* Remove shadows */
    /* box-shadow: 0 2px 5px rgba(0, 0, 0, .2); */
    font-weight: 700;
    z-index: 100;
}

.footer-text {
    font-size: 12px;
    text-align: center;
    /* Dark Mode Footer Text Color */
    color: #aaa;
    padding: 10px;
}

.popup-message {
    position: fixed;
    top: -60px;
    left: 50%;
    transform: translateX(-50%);
    /* Dark Mode Popup Background (Darker Green) */
    background-color: #218838;
    color: #fff;
    padding: 10px 20px;
    border-radius: 5px;
    z-index: 1000;
    opacity: 0;
    transition: opacity .5s ease-out, top .5s ease-out;
}

.popup-message.show {
    opacity: 1;
    top: 20px;
}

#temperature-value {
    font-size: 14px;
    /* Dark Mode Temperature Value Color */
    color: #bbbbbb;
    width: 30px;
    text-align: right;
}

#file-names {
    font-size: 14px;
    /* Dark Mode File Names Color */
    color: #bbbbbb;
    margin-left: 10px;
    margin-top: 5px;
    display: inline-block;
    max-width: 50%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    vertical-align: middle;
}

#overlay-image {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: url('https://github.com/crobperson/Overpriced-Haircut/blob/main/Screenshot.png?raw=true');
    background-size: cover;
    background-repeat: no-repeat;
    background-position: center;
    background-color: rgba(0,0,0,0.5); /* Keep overlay dark */
    z-index: 1001;
    pointer-events: none;
}

#overlay-image.show {
    display: block;
}
/* Style for the preview area next to the input */
#file-preview-container {
    display: flex;
    gap: 5px;
    margin-left: 10px;
    margin-right: 5px;
    max-height: 45px;
    overflow: hidden;
    align-items: center;
}

/* Style for individual preview thumbnails */
.file-preview-image {
    max-height: 40px;
    max-width: 40px;
    height: 40px;
    width: 40px;
    border-radius: 4px;
    object-fit: cover;
    /* Dark Mode Preview Border */
    border: 1px solid #555;
}

/* Style for images within the chat message (previews in user message) */
.message-image {
    max-width: 150px;
    max-height: 150px;
    border-radius: 8px;
    margin-top: 8px;
    cursor: pointer;
    display: block;
    /* Dark Mode Message Image Border */
    border: 1px solid #555;
}

/* Style for generated images in bot message */
.generated-message-image {
    max-width: 100%; /* Allow it to take full width of message bubble */
    max-height: 500px; /* Or a reasonable max height */
    border-radius: 8px;
    margin-top: 8px;
    display: block;
    /* Dark Mode Message Image Border */
    border: 1px solid #555;
    object-fit: contain; /* Ensure the whole image is visible */
}


/* Style for image container within the user message */
.user-message .images-container {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    margin-top: 5px;
    justify-content: flex-end;
}

.user-message > p {
    margin-bottom: 5px;
}

</style>
<script src=https://cdn.jsdelivr.net/npm/marked/marked.min.js></script>
<div class=container>
<div class=header>
<div class=model-select-container><label for=model-select>AI Model:</label> <select id=model-select>
<option value=gemini-2.5-flash-preview-05-20>Clifton Flash</option>
<option value=gemini-2.0-flash-preview-image-generation>Clifton Image Gen</option>
</select></div>
<div class=temperature-container><label for=temperature-slider>Temp:</label> <input id=temperature-slider
type=range max=1 min=0 step=0.1 value=1> <span id=temperature-value>1.0</span></div>
<div>
<button id=changelog-button class=button-primary>Changelog</button>
<button id=clear-chat-button class=button-secondary>Clear Chat</button>
<button id=regenerate-button class=button-secondary>Regenerate</button>
</div>
</div>
<div id=chat-container></div>
<div id=typing-indicator>Clifton is typing...</div>
<div id=input-area><label for=file-input class=file-upload-label>Choose File</label> <input id=file-input type=file
accept=.html,image/*,application/pdf,audio/* multiple> <span id=file-names></span> <div id="file-preview-container"></div><textarea id=input-box
placeholder="Enter your message..." rows=1></textarea> <button id=send-button>Send</button></div>
<p class=footer-text>Clifton® is not affiliated with Google in anyway!</div>
<div id=popup-container></div>
<div class=modal id=changelogModal>
<div class=modal-content><span class=close>×</span>
<h2>Changelog</h2>
<p><strong>Version 2.1 (May 10, 2025)</strong><br>- Added Image Generation model (Clifton Image Gen). Supports text-to-image and image-to-image (editing by uploading an image with your prompt).<br>
<p><strong>Version 2.0 (May 9, 2025)</strong><br>- Revamped the S**tty UI.<br><p><strong>Version 1.83 (April 9, 2025)</strong><br>- Added Image Previews Along With General Improvements<br><p><strong>Version 1.82 (March 31, 2025)</strong><br>- Improved the Clifton pro and flash model (I like chicken)<br><p><strong>Version 1.81 (Feb 6, 2025)</strong><br>- Improved the Clifton pro model (I've ran out of ideas)<br><p><strong>Version 1.8 (January 31, 2025)</strong><br>- Press ctrl 3 times<br><p><strong>Version 1.7 (January 22, 2025)</strong><br>- The Thinker is back... (Currently the best model)<br><p><strong>Version 1.65 (January 16, 2025)</strong><br>- Message Regeneration<br><p><strong>Version 1.6 (January 14, 2025)</strong><br>- Fixed bug!!!<br>
</div>
</div>
<div id="overlay-image"></div>
<script>
const b = ["01000001 01001001 01111010 01100001 01010011 01111001 01000010 01110000 01101000 01110011 01110010 01001001 00101101 01110001 01110110 01101001 01001101 01111000 01101111 01100001 01101111 01110110 01101100 00110000 01011001 01110111 01111000 01011111 01101001 01001101 01111000 01010011 01001011 00110100 01001110 00110000 01101000 01100110 01001101", "01000001 01001001 01111010 01100001 01010011 01111001 01000001 01001110 01000100 01011010 01110001 01001110 01111010 01101000 01001010 01010100 00110010 01110101 00110110 01011000 01001111 01101010 01000001 01111010 01001001 01010010 00110001 01100001 00101101 00110101 00101101 01101110 01001110 01110101 01000111 01100011 01100010 01110110 00110100"];
function str(e) {
e = e.replace(/[^01]/g, "");
let t = "";
for (let n = 0; n < e.length; n += 8) {
let o = e.substring(n, n + 8);
o.length < 8 ? console.warn(`Incomplete byte found at index ${n}: ${o}. Skipping.`) : t += String.fromCharCode(parseInt(o, 2))
}
return t
}
const k = b.map(str),
u = "https://generativelanguage.googleapis.com",
c = document.getElementById("chat-container"),
i = document.getElementById("input-box"),
m = document.getElementById("send-button"),
t = document.getElementById("typing-indicator"),
s = document.getElementById("model-select"),
f = document.getElementById("file-input"), // file input element
p = document.getElementById("popup-container"),
fileNamesSpan = document.getElementById("file-names"),
filePreviewContainer = document.getElementById("file-preview-container"); // Get the new preview container

let h = [], // Chat history
n = "gemini-2.5-flash-preview-04-17", // Default model
v = !1, // Error messages enabled/disabled flag
temp = 1; // Temperature setting

// NEW: Store data URLs for currently selected image previews
let currentImagePreviews = [];
let lastApiCallHistory = []; // Store history/parts *sent* to API for regeneration

const tempSlider = document.getElementById("temperature-slider"),
tempValueDisplay = document.getElementById("temperature-value");

function d(e) { // Display error message in chat if v is true
if (v) {
const t = document.createElement("div");
t.classList.add("message", "bot-message"), t.textContent = `Error: ${e}`, c.appendChild(t), c.scrollTop = c.scrollHeight
}
}

// Function to convert file to base64
function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result.split(',')[1]); // Get only the base64 part
        reader.onerror = error => reject(error);
        reader.readAsDataURL(file);
    });
}

// Function to make the API call for TEXT models (streaming)
async function g(apiKey, contents, modelName, outputElement) {
const safetySettings = [
{ "category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE" },
{ "category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE" },
{ "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE" },
{ "category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE" },
];

const apiRequestBody = {
contents: contents,
generationConfig: {
temperature: temp,
topP: .95,
maxOutputTokens: 81920,
responseMimeType: "text/plain"
},
safetySettings: safetySettings,
};


const response = await fetch(`${u}/v1beta/models/${modelName}:streamGenerateContent?alt=sse&key=${apiKey}`, {
method: "POST",
headers: {"Content-Type": "application/json"},
body: JSON.stringify(apiRequestBody)
});

if (!response.ok) {
let errorMsg = "Unknown API error";
try {
const errorData = await response.json();
errorMsg = errorData.error?.message || JSON.stringify(errorData);
} catch (e) {
errorMsg = `API request failed with status ${response.status}: ${response.statusText}`;
}
throw new Error(errorMsg);
}

const reader = response.body.getReader();
let accumulatedResponse = "";
let decodedChunk = "";
outputElement.innerHTML = "";

while (true) {
const { done, value } = await reader.read();
if (done) break;
decodedChunk += new TextDecoder().decode(value);
let newlineIndex;
while ((newlineIndex = decodedChunk.indexOf('\n')) >= 0) {
const line = decodedChunk.substring(0, newlineIndex).trim();
decodedChunk = decodedChunk.substring(newlineIndex + 1);
if (line.startsWith("data:")) {
try {
const jsonData = JSON.parse(line.substring(5));
if (jsonData.candidates && jsonData.candidates[0]?.content?.parts) {
const textPart = jsonData.candidates[0].content.parts[0]?.text;
if (textPart) {
accumulatedResponse += textPart;
outputElement.innerHTML = marked.parse(accumulatedResponse);
c.scrollTop = c.scrollHeight;
}
}
if (jsonData.candidates && jsonData.candidates[0]?.finishReason && jsonData.candidates[0].finishReason !== "STOP") {
console.warn("Stream stopped for reason:", jsonData.candidates[0].finishReason);
}
if (jsonData.promptFeedback?.blockReason) {
console.error("Request blocked:", jsonData.promptFeedback.blockReason);
throw new Error(`Request blocked due to safety settings: ${jsonData.promptFeedback.blockReason}`);
}
} catch (e) {
console.error("Error parsing SSE data line:", e, "Line:", line);
}
}
}
}
outputElement.innerHTML = marked.parse(accumulatedResponse);
cC();
return accumulatedResponse;
}

// Function to make API call for IMAGE GENERATION model (non-streaming)
async function generateImageApiCall(apiKey, contents, modelName) {
    const safetySettings = [
        { "category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE" },
        { "category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE" },
        { "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE" },
        { "category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE" },
    ];

    const apiRequestBody = {
        contents: contents,
        generationConfig: {
            responseModalities: ["TEXT", "IMAGE"]
            // Temperature, topP, maxOutputTokens are typically not used or different for image models
        },
        safetySettings: safetySettings,
    };

    const response = await fetch(`${u}/v1beta/models/${modelName}:generateContent?key=${apiKey}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(apiRequestBody)
    });

    if (!response.ok) {
        let errorMsg = "Unknown API error (Image Generation)";
        try {
            const errorData = await response.json();
            errorMsg = errorData.error?.message || JSON.stringify(errorData);
        } catch (e) {
            errorMsg = `Image API request failed with status ${response.status}: ${response.statusText}`;
        }
        throw new Error(errorMsg);
    }

    const responseData = await response.json();
    let botTextResponse = "";
    let botImageBase64 = null;
    let botImageMimeType = "image/png"; // Default

    if (responseData.candidates && responseData.candidates[0]?.content?.parts) {
        for (const part of responseData.candidates[0].content.parts) {
            if (part.text) {
                botTextResponse += part.text;
            }
            if (part.inlineData && part.inlineData.data) {
                botImageBase64 = part.inlineData.data;
                botImageMimeType = part.inlineData.mimeType;
            }
        }
    }

    if (responseData.promptFeedback?.blockReason) {
        console.error("Request blocked (Image Gen):", responseData.promptFeedback.blockReason);
        throw new Error(`Request blocked due to safety settings (Image Gen): ${responseData.promptFeedback.blockReason}`);
    }
    return { text: botTextResponse.trim(), imageBase64: botImageBase64, imageMimeType: botImageMimeType };
}


// Function to send message (Main User Action)
async function a() {
    const textInput = i.value.trim();
    const actualFiles = Array.from(f.files);
    const previewsToShow = [...currentImagePreviews];

    if (textInput === "" && actualFiles.length === 0) return;

    const userMessageDiv = document.createElement("div");
    userMessageDiv.classList.add("message", "user-message");
    if (textInput) {
        const textElement = document.createElement('p');
        textElement.textContent = textInput;
        userMessageDiv.appendChild(textElement);
    }
    if (previewsToShow.length > 0) {
        const imageContainer = document.createElement('div');
        imageContainer.className = 'images-container';
        previewsToShow.forEach(previewData => {
            const img = document.createElement('img');
            img.src = previewData.dataUrl;
            img.classList.add('message-image');
            img.title = previewData.name;
            img.alt = previewData.name;
            imageContainer.appendChild(img);
        });
        userMessageDiv.appendChild(imageContainer);
    }
    if (!textInput && previewsToShow.length === 0 && actualFiles.length > 0) {
        const fileInfoElement = document.createElement('p');
        fileInfoElement.textContent = `Attached ${actualFiles.length} file(s): ${actualFiles.map(file => file.name).join(', ')}`;
        userMessageDiv.appendChild(fileInfoElement);
    }
    c.appendChild(userMessageDiv);
    c.scrollTop = c.scrollHeight;

    i.value = "";
    f.value = "";
    fileNamesSpan.textContent = '';
    filePreviewContainer.innerHTML = '';
    currentImagePreviews = [];

    t.style.display = "block";

    let newUserParts = [];
    if (textInput) {
        newUserParts.push({ text: textInput });
    }

    if (n === "gemini-2.0-flash-preview-image-generation") {
        let hasTextPrompt = newUserParts.some(p => p.text && p.text.trim() !== "");
        if (!hasTextPrompt) {
            console.log("Image Gen: Text prompt is required.");
            t.style.display = "none";
            const errDiv = document.createElement("div");
            errDiv.classList.add("message", "bot-message");
            errDiv.textContent = "For image generation, a text prompt is required. You can optionally include one image for editing.";
            c.appendChild(errDiv);
            c.scrollTop = c.scrollHeight;
            return; // Abort send
        }

        if (actualFiles.length > 0) {
            const imageFile = actualFiles.find(file => file.type.startsWith('image/'));
            if (imageFile) {
                try {
                    const base64Data = await fileToBase64(imageFile);
                    newUserParts.push({
                        inline_data: {
                            mime_type: imageFile.type,
                            data: base64Data
                        }
                    });
                } catch (error) {
                    console.error(`Error converting image ${imageFile.name} to base64:`, error);
                    d(`Failed to process image ${imageFile.name} for generation: ${error.message}`);
                }
            }
        }
        const userMessageForHistory = { role: "user", parts: newUserParts };
        h.push(userMessageForHistory);
        await w(newUserParts); // Pass just the parts for image model
    } else { // Text models
        let fileProcessingPromises = actualFiles.map(async (file) => {
            try {
                if (file.type.startsWith('text/') || file.type === 'text/html' || file.type === 'application/json' || file.type === 'application/xml') {
                    const content = await fT(file);
                    return { text: `--- File Start: ${file.name} ---\n${content}\n--- File End: ${file.name} ---` };
                } else if (file.type.startsWith('image/') || file.type.startsWith('audio/') || file.type === 'application/pdf' || file.type.startsWith('video/')) {
                    const uploadedFile = await z(file);
                    return { file_data: { mime_type: file.type, file_uri: uploadedFile.file.uri } };
                } else {
                    console.warn(`Unsupported file type for direct API processing: ${file.name} (${file.type}). Sending as text note.`);
                    return { text: `[Attached file: ${file.name} (${file.type}) - Content not processed]` };
                }
            } catch (error) {
                console.error(`Error processing file ${file.name}:`, error);
                d(`Failed to process file ${file.name}: ${error.message}`);
                return null;
            }
        });
        const filePartsForApi = (await Promise.all(fileProcessingPromises)).filter(p => p !== null);
        newUserParts.push(...filePartsForApi);

        if (newUserParts.length > 0) {
            const newUserMessage = { role: "user", parts: newUserParts };
            const historyForApi = [...h, newUserMessage];
            h.push(newUserMessage);
            await w(historyForApi);
        } else {
            console.log("No valid content (text or processed files) to send.");
            t.style.display = "none";
        }
    }
}


// Read file as text
function fT(file) { // fileToText
return new Promise(((resolve, reject) => {
const reader = new FileReader;
reader.onload = e => resolve(e.target.result);
reader.onerror = e => reject(e);
reader.readAsText(file);
}))
}

// Main function to handle conversation flow and API calls
async function w(conversationHistoryOrPartsForImageGen) {
    // Store what's being sent to the API for potential regeneration
    if (n === "gemini-2.0-flash-preview-image-generation") {
        lastApiCallHistory = conversationHistoryOrPartsForImageGen; // These are userParts
    } else {
        lastApiCallHistory = [...conversationHistoryOrPartsForImageGen]; // This is full history
    }

    let botReplied = false;
    const botMessageDiv = document.createElement("div");
    botMessageDiv.classList.add("message", "bot-message");
    botMessageDiv.innerHTML = "<i>Clifton is typing...</i>";
    c.appendChild(botMessageDiv);
    c.scrollTop = c.scrollHeight;
    t.style.display = 'block';

    for (const apiKey of k) {
        try {
            if (n === "gemini-2.0-flash-preview-image-generation") {
                const userParts = conversationHistoryOrPartsForImageGen; // This is already the parts array
                const imageGenContents = [{ role: "user", parts: userParts }];

                const result = await generateImageApiCall(apiKey, imageGenContents, n);
                botMessageDiv.innerHTML = ''; // Clear "typing..."

                let contentAdded = false;
                let modelPartsForHistory = [];

                if (result.text) {
                    const textElement = document.createElement('div');
                    textElement.innerHTML = marked.parse(result.text);
                    botMessageDiv.appendChild(textElement);
                    modelPartsForHistory.push({ text: result.text });
                    contentAdded = true;
                }
                if (result.imageBase64) {
                    const imgElement = document.createElement('img');
                    imgElement.src = `data:${result.imageMimeType};base64,${result.imageBase64}`;
                    imgElement.classList.add('generated-message-image');
                    imgElement.alt = "Generated Image";
                    botMessageDiv.appendChild(imgElement);
                    contentAdded = true;
                    if (!result.text) { // If only image, add placeholder to history
                        modelPartsForHistory.push({ text: "[Image Generated]" });
                    }
                }

                if (!contentAdded) {
                    botMessageDiv.innerHTML = "<i>Image model returned no text or image.</i>";
                }

                if (modelPartsForHistory.length > 0) {
                    h.push({ role: "model", parts: modelPartsForHistory });
                }
                botReplied = true;
                break;
            } else { // Text models
                const botResponseText = await g(apiKey, conversationHistoryOrPartsForImageGen, n, botMessageDiv);
                if (botResponseText !== null && botResponseText.trim() !== "") {
                    h.push({ role: "model", parts: [{ text: botResponseText }] });
                    botReplied = true;
                    break;
                } else if (botResponseText === "") {
                    botMessageDiv.innerHTML = "<i>Received an empty response.</i>";
                    // h.push({ role: "model", parts: [{ text: "" }] }); // Optionally log empty responses
                    botReplied = true;
                    break;
                }
            }
        } catch (error) {
            console.error(`Error during API call with key [...] for model ${n}: ${error.message}`);
            d(error.message);
            botMessageDiv.innerHTML = `<span style="color: red;">Error: ${error.message}</span>`;
        }
    }

    if (!botReplied && !botMessageDiv.innerHTML.includes("Error:")) {
        botMessageDiv.textContent = "I'm sorry, I'm currently unable to process your request after trying all available resources. Please try again later.";
    }

    t.style.display = "none";
    c.scrollTop = c.scrollHeight;
    cC();
}


// Upload file using Google's resumable upload (for text models)
async function z(file) { // uploadFileToGoogle
return new Promise(async (resolve, reject) => {
try {
const uploadApiKey = k[0];
if (!uploadApiKey) return reject(new Error("No API key available for file uploads."));

const startResponse = await fetch(`${u}/upload/v1beta/files?key=${uploadApiKey}`, {
method: "POST",
headers: {
"X-Goog-Upload-Protocol": "resumable",
"X-Goog-Upload-Command": "start",
"X-Goog-Upload-Header-Content-Length": file.size.toString(),
"X-Goog-Upload-Header-Content-Type": file.type,
"Content-Type": "application/json"
},
body: JSON.stringify({ file: { display_name: file.name }})
});

if (!startResponse.ok || startResponse.status !== 200) {
let errorMsg = `Failed to start upload (Status: ${startResponse.status})`;
try { errorMsg = (await startResponse.json()).error?.message || errorMsg; } catch (_) {}
return reject(new Error(errorMsg));
}

const uploadUrl = startResponse.headers.get("X-Goog-Upload-URL");
if (!uploadUrl) return reject(new Error("Failed to get upload URL from start response."));

const uploadResponse = await fetch(uploadUrl, {
method: "POST",
headers: {
"X-Goog-Upload-Offset": "0",
"X-Goog-Upload-Command": "upload, finalize"
},
body: file
});

if (!uploadResponse.ok) {
let errorMsg = `File upload failed (Status: ${uploadResponse.status})`;
try {
const errorData = await uploadResponse.json();
errorMsg = errorData.error?.message || JSON.stringify(errorData) || errorMsg;
} catch (_) { errorMsg += `: ${uploadResponse.statusText}`; }
return reject(new Error(errorMsg));
}
const uploadResult = await uploadResponse.json();
if (!uploadResult.file?.uri) return reject(new Error("Upload succeeded but response did not contain file URI."));
resolve({ file: { uri: uploadResult.file.uri } });
} catch (error) {
console.error("File Upload z() Error:", error);
reject(error);
}
});
}

// --- Event Listeners ---
tempSlider.addEventListener("input", () => {
temp = parseFloat(tempSlider.value);
tempValueDisplay.textContent = temp.toFixed(1);
// Show/hide temp slider based on model
const isImageModel = n === "gemini-2.0-flash-preview-image-generation";
document.querySelector('.temperature-container').style.display = isImageModel ? 'none' : 'flex';

});

s.addEventListener("change", () => {
n = s.value;
console.log(`Model switched to: ${n}`);
const isImageModel = n === "gemini-2.0-flash-preview-image-generation";
document.querySelector('.temperature-container').style.display = isImageModel ? 'none' : 'flex';


// Optionally clear history or notify user
// h = []; c.innerHTML = ''; sp(`Model changed to ${n}. Chat history may not be fully compatible.`);
});

m.addEventListener("click", a);
i.addEventListener("keydown", (e => { if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); a(); }}));

f.addEventListener('change', function() {
fileNamesSpan.textContent = '';
filePreviewContainer.innerHTML = '';
currentImagePreviews = [];
let nonImageFileNames = [];
if (f.files && f.files.length > 0) {
const filePromises = Array.from(f.files).map(file => {
return new Promise((resolve) => {
if (file.type.startsWith('image/')) {
const reader = new FileReader();
reader.onload = (e) => {
const dataUrl = e.target.result;
currentImagePreviews.push({ name: file.name, dataUrl: dataUrl });
const img = document.createElement('img');
img.src = dataUrl;
img.classList.add('file-preview-image');
img.title = file.name;
img.alt = file.name;
filePreviewContainer.appendChild(img);
resolve();
};
reader.onerror = () => { console.error("Error reading file:", file.name); nonImageFileNames.push(file.name + " (preview failed)"); resolve(); };
reader.readAsDataURL(file);
} else { nonImageFileNames.push(file.name); resolve(); }
});
});
Promise.all(filePromises).then(() => {
if (nonImageFileNames.length > 0) { fileNamesSpan.textContent = nonImageFileNames.join(', '); }
filePreviewContainer.style.display = currentImagePreviews.length > 0 ? 'flex' : 'none';
});
} else { filePreviewContainer.style.display = 'none'; }
});

// --- Buttons and Modals ---
const ld = document.createElement("p");
ld.id = "last-updated";
ld.textContent = "Last updated: May 10th, 2025, 10:00 AM"; // Update timestamp
document.body.appendChild(ld);

const ch = document.getElementById("changelogModal"),
bb = document.getElementById("changelog-button"),
cl = document.getElementsByClassName("close")[0];
if (bb && ch && cl) {
bb.onclick = function() { ch.style.display = "block" };
cl.onclick = function() { ch.style.display = "none" };
window.onclick = function(event) { if (event.target == ch) { ch.style.display = "none"; }};
} else { console.warn("Changelog modal elements not found."); }

function sp(message) {
const popup = document.createElement("div");
popup.classList.add("popup-message");
popup.textContent = message;
p.appendChild(popup);
popup.offsetWidth;
popup.classList.add("show");
setTimeout(() => {
popup.classList.remove("show");
setTimeout(() => { if (popup.parentNode) { popup.remove(); }}, 500);
}, 2500);
}

function cC() {
c.querySelectorAll(".bot-message pre > code").forEach((codeBlock => {
const preElement = codeBlock.parentElement;
if (preElement && !preElement.querySelector(".copy-button")) {
const button = document.createElement("button");
button.className = "copy-button";
button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>';
button.title = "Copy code";
button.addEventListener("click", () => {
navigator.clipboard.writeText(codeBlock.innerText).then(() => {
button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M9 16.17 4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>';
button.title = "Copied!";
setTimeout(() => {
button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>';
button.title = "Copy code";
}, 1500);
}).catch(err => { console.error("Failed to copy code: ", err); button.title = "Copy failed!"; });
});
if (getComputedStyle(preElement).position === 'static') { preElement.style.position = "relative"; }
preElement.appendChild(button);
}
}));
}

const cb = document.getElementById("clear-chat-button");
if (cb) {
cb.addEventListener("click", () => {
c.innerHTML = ""; h = []; lastApiCallHistory = []; sp("Chat cleared.");
});
}

const regenerateButton = document.getElementById("regenerate-button");
if (regenerateButton) {
    regenerateButton.addEventListener("click", async () => {
        if (h.length === 0 || h[h.length - 1].role === 'user') {
            sp("Nothing to regenerate from the bot.");
            return;
        }

        // Remove the last bot message from display and history
        h.pop(); // Remove last bot message from history
        const botMessages = c.querySelectorAll(".message.bot-message");
        if (botMessages.length > 0) {
            c.removeChild(botMessages[botMessages.length - 1]); // Remove last bot message from DOM
        }

        if (lastApiCallHistory && ( (Array.isArray(lastApiCallHistory) && lastApiCallHistory.length > 0) || (typeof lastApiCallHistory === 'object' && Object.keys(lastApiCallHistory).length > 0) ) ) {
            sp("Regenerating response...");
            // `lastApiCallHistory` is already in the correct format (parts or full history)
            // that `w` expects for the model that was active during the last call.
            // We assume model 'n' hasn't changed in a way that invalidates `lastApiCallHistory`.
            await w(lastApiCallHistory);
        } else {
            sp("Cannot regenerate: No previous API call context found.");
            // Attempt to restore the bot message if regeneration fails early
            // This part is complex; for now, if lastApiCallHistory is missing, it's an issue.
        }
    });
} else { console.warn("Regenerate button not found."); }


document.addEventListener("keydown", (function(event) {
if (event.altKey && event.shiftKey && event.key === 'E') {
v = !v; sp(v ? "Error messages will be shown in chat." : "Error messages hidden.");
}
}));

let ctrlCount = 0;
let ctrlPressedTimeout;
const overlayImage = document.getElementById('overlay-image');
if (overlayImage) {
document.addEventListener('keydown', function(event) {
if (event.key === 'Control' || event.key === 'Meta') {
ctrlCount++;
clearTimeout(ctrlPressedTimeout);
if (ctrlCount >= 3) { ctrlCount = 0; overlayImage.classList.toggle('show'); }
else { ctrlPressedTimeout = setTimeout(() => { ctrlCount = 0; }, 500); }
} else if (!event.ctrlKey && !event.metaKey) {
if (event.key !== 'Control' && event.key !== 'Meta') { ctrlCount = 0; clearTimeout(ctrlPressedTimeout); }
}
});
const preloadImage = new Image();
preloadImage.src = 'https://github.com/crobperson/Overpriced-Haircut/blob/main/Screenshot.png?raw=true';
} else { console.warn("Overlay image element not found."); }

// Initial UI setup based on default model
const initialIsImageModel = s.value === "gemini-2.0-flash-preview-image-generation";
document.querySelector('.temperature-container').style.display = initialIsImageModel ? 'none' : 'flex';


cC();
</script>
</html>
